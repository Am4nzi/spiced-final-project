{"ast":null,"code":"var _jsxFileName = \"/home/spiced/spiced/spiced-final-project/src/components/PadEditorItem/RecordButton.js\";\nimport React, { useContext } from 'react';\nimport { TOGGLE_IS_RECORDING } from '../../reducers/types';\nimport { Context } from '../../contexts/SamplerContext';\nimport { updateSources } from '../../actions';\nimport Colors from '../../Config/ColorScheme';\nimport './PadEditorButtons.css';\nvar recorder = null;\nvar recordedChunks = [];\nvar style = {\n  background: Colors.gray,\n  color: Colors.red,\n  width: \"90%\",\n  textAlign: \"center\",\n  border: \"1px solid \".concat(Colors.white),\n  display: \"grid\",\n  gridTemplateRows: \"1fr\",\n  gridTemplateColumns: \"1fr\",\n  justifyContent: \"center\",\n  margin: \"1vh auto\"\n};\nexport default (function () {\n  var context = useContext(Context);\n\n  var toggleIsRecording = function toggleIsRecording(monitor) {\n    var isRecording = !context.isRecording;\n    context.dispatch({\n      type: TOGGLE_IS_RECORDING,\n      payload: {\n        isRecording: isRecording,\n        monitor: monitor\n      }\n    });\n  };\n\n  var startRecording = function startRecording() {\n    navigator.mediaDevices.getUserMedia({\n      audio: true,\n      video: false\n    }).then(function (stream) {\n      var monitorStream = stream.clone();\n      var monSource = context.ctx.createMediaStreamSource(monitorStream);\n      monSource.connect(context.ctx.destination);\n      var recSource = context.ctx.createMediaStreamSource(stream);\n      var recDestination = context.ctx.createMediaStreamDestination();\n      recSource.connect(recDestination);\n      recorder = new MediaRecorder(recDestination.stream);\n      recorder.start();\n\n      recorder.onstop = function () {\n        var recordedBlob = new Blob(recordedChunks, {\n          'type': 'audio/ogg; codecs=opus'\n        });\n        recordedBlob.name = \"sample record\";\n        recordedChunks = [];\n        recorder = null;\n        updateSources(context, recordedBlob);\n        var monitorTracks = monitorStream.getAudioTracks();\n        monitorTracks.forEach(function (track) {\n          return track.stop();\n        });\n        var recTracks = stream.getAudioTracks();\n        recTracks.forEach(function (track) {\n          return track.stop();\n        });\n      };\n\n      recorder.ondataavailable = function (e) {\n        recordedChunks.push(e.data);\n      };\n\n      toggleIsRecording(monSource);\n    }).catch(function (err) {\n      return console.log(err);\n    });\n  };\n\n  var stopRecording = function stopRecording() {\n    recorder.stop();\n    context.monitor.disconnect();\n    toggleIsRecording(null);\n  };\n\n  var renderButtonContent = function renderButtonContent() {\n    if (!context.isRecording) {\n      return React.createElement(\"button\", {\n        className: \"editor-btn btn-play\",\n        id: \"rec\",\n        onClick: function onClick(e) {\n          startRecording();\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 66\n        },\n        __self: this\n      }, \"REC\");\n    }\n\n    return React.createElement(\"button\", {\n      style: {\n        backgroundColor: Colors.red\n      },\n      className: \"editor-btn btn-play\",\n      id: \"rec\",\n      onClick: function onClick(e) {\n        stopRecording();\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 69\n      },\n      __self: this\n    }, \"STOP\");\n  };\n\n  return React.createElement(\"div\", {\n    className: \"pad-item-wrapper\",\n    style: style,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 80\n    },\n    __self: this\n  }, renderButtonContent());\n});","map":{"version":3,"sources":["/home/spiced/spiced/spiced-final-project/src/components/PadEditorItem/RecordButton.js"],"names":["React","useContext","TOGGLE_IS_RECORDING","Context","updateSources","Colors","recorder","recordedChunks","style","background","gray","color","red","width","textAlign","border","white","display","gridTemplateRows","gridTemplateColumns","justifyContent","margin","context","toggleIsRecording","monitor","isRecording","dispatch","type","payload","startRecording","navigator","mediaDevices","getUserMedia","audio","video","then","stream","monitorStream","clone","monSource","ctx","createMediaStreamSource","connect","destination","recSource","recDestination","createMediaStreamDestination","MediaRecorder","start","onstop","recordedBlob","Blob","name","monitorTracks","getAudioTracks","forEach","track","stop","recTracks","ondataavailable","e","push","data","catch","err","console","log","stopRecording","disconnect","renderButtonContent","backgroundColor"],"mappings":";AAAA,OAAOA,KAAP,IAAeC,UAAf,QAAgC,OAAhC;AACA,SAAQC,mBAAR,QAAkC,sBAAlC;AACA,SAAQC,OAAR,QAAsB,+BAAtB;AACA,SAAQC,aAAR,QAA4B,eAA5B;AACA,OAAOC,MAAP,MAAmB,0BAAnB;AACA,OAAO,wBAAP;AAEA,IAAIC,QAAQ,GAAG,IAAf;AACA,IAAIC,cAAc,GAAG,EAArB;AACA,IAAIC,KAAK,GAAG;AACRC,EAAAA,UAAU,EAAEJ,MAAM,CAACK,IADX;AAERC,EAAAA,KAAK,EAAEN,MAAM,CAACO,GAFN;AAGRC,EAAAA,KAAK,EAAE,KAHC;AAIRC,EAAAA,SAAS,EAAE,QAJH;AAKRC,EAAAA,MAAM,sBAAeV,MAAM,CAACW,KAAtB,CALE;AAMRC,EAAAA,OAAO,EAAE,MAND;AAORC,EAAAA,gBAAgB,EAAE,KAPV;AAQRC,EAAAA,mBAAmB,EAAE,KARb;AASRC,EAAAA,cAAc,EAAE,QATR;AAURC,EAAAA,MAAM,EAAE;AAVA,CAAZ;AAaA,gBAAe,YAAM;AACjB,MAAMC,OAAO,GAAGrB,UAAU,CAACE,OAAD,CAA1B;;AACA,MAAMoB,iBAAiB,GAAG,SAApBA,iBAAoB,CAACC,OAAD,EAAa;AACnC,QAAIC,WAAW,GAAG,CAACH,OAAO,CAACG,WAA3B;AACAH,IAAAA,OAAO,CAACI,QAAR,CAAiB;AAACC,MAAAA,IAAI,EAAEzB,mBAAP;AAA4B0B,MAAAA,OAAO,EAAE;AAAEH,QAAAA,WAAW,EAAXA,WAAF;AAAeD,QAAAA,OAAO,EAAPA;AAAf;AAArC,KAAjB;AACH,GAHD;;AAKA,MAAMK,cAAc,GAAG,SAAjBA,cAAiB,GAAM;AACzBC,IAAAA,SAAS,CAACC,YAAV,CAAuBC,YAAvB,CAAoC;AAACC,MAAAA,KAAK,EAAE,IAAR;AAAcC,MAAAA,KAAK,EAAE;AAArB,KAApC,EACKC,IADL,CACU,UAAAC,MAAM,EAAI;AACZ,UAAIC,aAAa,GAAGD,MAAM,CAACE,KAAP,EAApB;AACA,UAAIC,SAAS,GAAGjB,OAAO,CAACkB,GAAR,CAAYC,uBAAZ,CAAoCJ,aAApC,CAAhB;AACAE,MAAAA,SAAS,CAACG,OAAV,CAAkBpB,OAAO,CAACkB,GAAR,CAAYG,WAA9B;AACA,UAAIC,SAAS,GAAGtB,OAAO,CAACkB,GAAR,CAAYC,uBAAZ,CAAoCL,MAApC,CAAhB;AACA,UAAIS,cAAc,GAAGvB,OAAO,CAACkB,GAAR,CAAYM,4BAAZ,EAArB;AACAF,MAAAA,SAAS,CAACF,OAAV,CAAkBG,cAAlB;AACAvC,MAAAA,QAAQ,GAAG,IAAIyC,aAAJ,CAAkBF,cAAc,CAACT,MAAjC,CAAX;AACA9B,MAAAA,QAAQ,CAAC0C,KAAT;;AACA1C,MAAAA,QAAQ,CAAC2C,MAAT,GAAkB,YAAM;AACpB,YAAIC,YAAY,GAAG,IAAIC,IAAJ,CAAS5C,cAAT,EAAyB;AAAE,kBAAS;AAAX,SAAzB,CAAnB;AACA2C,QAAAA,YAAY,CAACE,IAAb,GAAoB,eAApB;AACA7C,QAAAA,cAAc,GAAG,EAAjB;AACAD,QAAAA,QAAQ,GAAG,IAAX;AACAF,QAAAA,aAAa,CAACkB,OAAD,EAAU4B,YAAV,CAAb;AACA,YAAIG,aAAa,GAAGhB,aAAa,CAACiB,cAAd,EAApB;AACAD,QAAAA,aAAa,CAACE,OAAd,CAAsB,UAAAC,KAAK;AAAA,iBAAIA,KAAK,CAACC,IAAN,EAAJ;AAAA,SAA3B;AACA,YAAIC,SAAS,GAAGtB,MAAM,CAACkB,cAAP,EAAhB;AACAI,QAAAA,SAAS,CAACH,OAAV,CAAkB,UAAAC,KAAK;AAAA,iBAAIA,KAAK,CAACC,IAAN,EAAJ;AAAA,SAAvB;AACH,OAVD;;AAWAnD,MAAAA,QAAQ,CAACqD,eAAT,GAA4B,UAACC,CAAD,EAAO;AAC/BrD,QAAAA,cAAc,CAACsD,IAAf,CAAoBD,CAAC,CAACE,IAAtB;AACH,OAFD;;AAGAvC,MAAAA,iBAAiB,CAACgB,SAAD,CAAjB;AACH,KAzBL,EA0BKwB,KA1BL,CA0BW,UAAAC,GAAG;AAAA,aAAIC,OAAO,CAACC,GAAR,CAAYF,GAAZ,CAAJ;AAAA,KA1Bd;AA2BH,GA5BD;;AA6BA,MAAMG,aAAa,GAAG,SAAhBA,aAAgB,GAAM;AACxB7D,IAAAA,QAAQ,CAACmD,IAAT;AACAnC,IAAAA,OAAO,CAACE,OAAR,CAAgB4C,UAAhB;AACA7C,IAAAA,iBAAiB,CAAC,IAAD,CAAjB;AACH,GAJD;;AAKA,MAAM8C,mBAAmB,GAAG,SAAtBA,mBAAsB,GAAM;AAC9B,QAAG,CAAC/C,OAAO,CAACG,WAAZ,EAAwB;AACpB,aAAO;AAAQ,QAAA,SAAS,EAAC,qBAAlB;AAAwC,QAAA,EAAE,EAAC,KAA3C;AAAiD,QAAA,OAAO,EAAE,iBAACmC,CAAD,EAAO;AAAE/B,UAAAA,cAAc;AAAI,SAArF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAAP;AACH;;AACD,WACI;AACA,MAAA,KAAK,EAAE;AAACyC,QAAAA,eAAe,EAAEjE,MAAM,CAACO;AAAzB,OADP;AAEA,MAAA,SAAS,EAAC,qBAFV;AAGA,MAAA,EAAE,EAAC,KAHH;AAIA,MAAA,OAAO,EAAE,iBAACgD,CAAD,EAAO;AAAEO,QAAAA,aAAa;AAAI,OAJnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cADJ;AAUH,GAdD;;AAeA,SACI;AAAK,IAAA,SAAS,EAAC,kBAAf;AAAkC,IAAA,KAAK,EAAE3D,KAAzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACK6D,mBAAmB,EADxB,CADJ;AAKH,CA7DD","sourcesContent":["import React, {useContext} from 'react';\nimport {TOGGLE_IS_RECORDING} from '../../reducers/types';\nimport {Context} from '../../contexts/SamplerContext';\nimport {updateSources} from '../../actions'\nimport Colors from '../../Config/ColorScheme';\nimport './PadEditorButtons.css';\n\nlet recorder = null;\nlet recordedChunks = [];\nlet style = { \n    background: Colors.gray, \n    color: Colors.red, \n    width: \"90%\", \n    textAlign: \"center\",\n    border: `1px solid ${Colors.white}`,\n    display: \"grid\",\n    gridTemplateRows: \"1fr\",\n    gridTemplateColumns: \"1fr\",\n    justifyContent: \"center\",\n    margin: \"1vh auto\"\n}\n\nexport default () => {\n    const context = useContext(Context);\n    const toggleIsRecording = (monitor) => {\n        let isRecording = !context.isRecording\n        context.dispatch({type: TOGGLE_IS_RECORDING, payload: { isRecording, monitor }});\n    }\n    \n    const startRecording = () => {\n        navigator.mediaDevices.getUserMedia({audio: true, video: false})\n            .then(stream => {\n                let monitorStream = stream.clone()\n                let monSource = context.ctx.createMediaStreamSource(monitorStream);\n                monSource.connect(context.ctx.destination);\n                let recSource = context.ctx.createMediaStreamSource(stream);\n                let recDestination = context.ctx.createMediaStreamDestination();\n                recSource.connect(recDestination);\n                recorder = new MediaRecorder(recDestination.stream);\n                recorder.start()\n                recorder.onstop = () => {\n                    let recordedBlob = new Blob(recordedChunks, { 'type' : 'audio/ogg; codecs=opus' });\n                    recordedBlob.name = \"sample record\";\n                    recordedChunks = [];\n                    recorder = null;\n                    updateSources(context, recordedBlob)\n                    let monitorTracks = monitorStream.getAudioTracks();\n                    monitorTracks.forEach(track => track.stop());\n                    let recTracks = stream.getAudioTracks();\n                    recTracks.forEach(track => track.stop());\n                }\n                recorder.ondataavailable  = (e) => {\n                    recordedChunks.push(e.data);\n                }\n                toggleIsRecording(monSource);\n            })\n            .catch(err => console.log(err))\n    }\n    const stopRecording = () => {\n        recorder.stop();\n        context.monitor.disconnect();\n        toggleIsRecording(null);\n    }\n    const renderButtonContent = () => {\n        if(!context.isRecording){\n            return <button className=\"editor-btn btn-play\" id=\"rec\" onClick={(e) => { startRecording() }}>REC</button>\n        }\n        return (\n            <button \n            style={{backgroundColor: Colors.red }} \n            className=\"editor-btn btn-play\" \n            id=\"rec\" \n            onClick={(e) => { stopRecording() }}\n            >\n            STOP\n            </button>\n        )\n    }\n    return (\n        <div className=\"pad-item-wrapper\" style={style}>\n            {renderButtonContent()}\n        </div>\n    )\n}"]},"metadata":{},"sourceType":"module"}