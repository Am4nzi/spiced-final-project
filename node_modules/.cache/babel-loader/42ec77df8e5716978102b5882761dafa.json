{"ast":null,"code":"import _objectSpread from \"/home/spiced/spiced/sampler2/Sampler/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _regeneratorRuntime from \"/home/spiced/spiced/sampler2/Sampler/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/spiced/spiced/sampler2/Sampler/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport * as types from '../reducers/types';\nimport Colors from '../Config/ColorScheme';\nexport var setCTX =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(context) {\n    var ctx;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            ctx = !context.ctx ? new (window.AudioContext || window.webkitAudioContext)() : null;\n            createAnalyser(context, ctx);\n\n          case 2:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function setCTX(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var createAnalyser = function createAnalyser(context, ctx) {\n  var analyser = ctx.createAnalyser();\n  analyser.connect(ctx.destination);\n  context.dispatch({\n    type: types.CREATE_ANALYSER,\n    payload: {\n      ctx: ctx,\n      analyser: analyser\n    }\n  });\n};\nexport var updateSources = function updateSources(context, file) {\n  var reader = new FileReader();\n\n  reader.onload = function (e) {\n    context.ctx.decodeAudioData(e.target.result, function (buffer) {\n      var sources = _objectSpread({}, context.sources);\n\n      var name = file.name.split('.')[0];\n      var waveformData = buffer.getChannelData(0);\n      sources[context.selectedPad] = {\n        buffer: buffer,\n        name: name,\n        isPlaying: false,\n        waveformData: waveformData\n      };\n      var gridPadsArr = context.gridPadsArr;\n      var newSource = context.ctx.createBufferSource();\n      newSource.buffer = buffer;\n      gridPadsArr[context.selectedPad].source = newSource;\n      gridPadsArr[context.selectedPad].source.start();\n      gridPadsArr[context.selectedPad].sampleEnd = buffer.duration;\n      gridPadsArr[context.selectedPad].gainNode = context.ctx.createGain();\n      gridPadsArr[context.selectedPad].gainNode.connect(context.ctx.destination);\n      context.dispatch({\n        type: types.UPDATE_SOURCES,\n        payload: {\n          sources: sources,\n          gridPadsArr: gridPadsArr\n        }\n      });\n    });\n  };\n\n  reader.readAsArrayBuffer(file);\n};\nexport var handlePadTrigger = function handlePadTrigger(context, padId) {\n  var velocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 127;\n  var selectedSource = context.sources[padId];\n  var selectedPad = padId;\n\n  if (selectedSource && selectedSource.buffer) {\n    if (context.gridPadsArr[padId].source && context.gridPadsArr[padId].selfMuted) {\n      context.gridPadsArr[padId].source.stop();\n    }\n\n    var gridPadsArr = context.gridPadsArr;\n    var newSource = context.ctx.createBufferSource();\n    newSource.buffer = context.sources[padId].buffer;\n    gridPadsArr[padId].source = newSource;\n    gridPadsArr[padId].isPlaying = true;\n\n    if (context.selectedPad !== padId) {\n      context.dispatch({\n        type: types.HANDLE_PAD_TRIGGER,\n        payload: {\n          gridPadsArr: gridPadsArr,\n          selectedPad: selectedPad\n        }\n      });\n    }\n\n    newSource.connect(context.gridPadsArr[padId].gainNode);\n    newSource.detune.value = context.gridPadsArr[padId].detune;\n    var currentGain = velocity !== 127 ? Math.pow(velocity, 2) / Math.pow(127, 2) : context.gridPadsArr[padId].currentGain;\n    context.gridPadsArr[padId].gainNode.gain.setValueAtTime(currentGain, context.ctx.currentTime);\n    context.gridPadsArr[padId].source.start(context.ctx.currentTime, context.gridPadsArr[padId].sampleStart, context.gridPadsArr[padId].sampleEnd);\n    context.gridPadsArr[padId].source.stop(context.ctx.currentTime + context.gridPadsArr[padId].sampleEnd);\n  } else {\n    if (context.selectedPad !== padId) {\n      context.dispatch({\n        type: types.HANDLE_PAD_TRIGGER,\n        payload: {\n          selectedPad: selectedPad\n        }\n      });\n    }\n  }\n};\nexport var handlePadStop = function handlePadStop(context, padId, gridPadsArr) {\n  if (context.gridPadsArr[padId].source && context.gridPadsArr[padId].selfMuted) {\n    context.gridPadsArr[padId].source.stop();\n    context.gridPadsArr[padId].isPlaying = false;\n    context.dispatch({\n      type: types.HANDLE_PAD_STOP,\n      payload: {\n        gridPadsArr: gridPadsArr\n      }\n    });\n  }\n};\nexport var updateEditorData = function updateEditorData(_ref2) {\n  var context = _ref2.context,\n      cmd = _ref2.cmd,\n      val = _ref2.val;\n  var newPadsArr = context.gridPadsArr;\n  var selectedPad = context.selectedPad;\n\n  if (cmd === \"start\") {\n    if (val >= newPadsArr[context.selectedPad].sampleEnd) return;\n    newPadsArr[context.selectedPad].sampleStart = Number(val);\n  }\n\n  if (cmd === \"end\") {\n    if (val <= newPadsArr[context.selectedPad].sampleStart) return;\n    newPadsArr[context.selectedPad].sampleEnd = Number(val);\n  }\n\n  if (cmd === \"gain\") {\n    newPadsArr[context.selectedPad].currentGain = val;\n  }\n\n  if (cmd === \"detune\" && val !== \"Current\") {\n    newPadsArr[context.selectedPad].detune = val;\n  }\n\n  if (cmd === \"prev\") {\n    selectedPad = context.selectedPad + val < 0 ? context.gridPadsArr.length - 1 : context.selectedPad + val;\n  }\n\n  if (cmd === \"next\") {\n    selectedPad = context.selectedPad + val > context.gridPadsArr.length - 1 ? 0 : context.selectedPad + val;\n  }\n\n  if (cmd === \"play\") {\n    handlePadTrigger(context, context.selectedPad);\n  }\n\n  if (cmd === \"stop\") {\n    handlePadStop(context.selectedPad, newPadsArr);\n  }\n\n  if (cmd === \"color\") {\n    newPadsArr[context.selectedPad].color = Colors[val];\n  }\n\n  var payload = {\n    gridPadsArr: newPadsArr,\n    selectedPad: selectedPad\n  };\n  context.dispatch({\n    type: types.UPDATE_EDITOR_DATA,\n    payload: payload\n  });\n};","map":{"version":3,"sources":["/home/spiced/spiced/sampler2/Sampler/src/actions/index.js"],"names":["types","Colors","setCTX","context","ctx","window","AudioContext","webkitAudioContext","createAnalyser","analyser","connect","destination","dispatch","type","CREATE_ANALYSER","payload","updateSources","file","reader","FileReader","onload","e","decodeAudioData","target","result","buffer","sources","name","split","waveformData","getChannelData","selectedPad","isPlaying","gridPadsArr","newSource","createBufferSource","source","start","sampleEnd","duration","gainNode","createGain","UPDATE_SOURCES","readAsArrayBuffer","handlePadTrigger","padId","velocity","selectedSource","selfMuted","stop","HANDLE_PAD_TRIGGER","detune","value","currentGain","Math","pow","gain","setValueAtTime","currentTime","sampleStart","handlePadStop","HANDLE_PAD_STOP","updateEditorData","cmd","val","newPadsArr","Number","length","color","UPDATE_EDITOR_DATA"],"mappings":"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","sourcesContent":["import * as types from '../reducers/types'\nimport Colors from '../Config/ColorScheme';\n\nexport const setCTX = async (context) => {\n    let ctx = !context.ctx ? new (window.AudioContext || window.webkitAudioContext)() : null;\n    createAnalyser(context, ctx)\n}\nexport const createAnalyser = (context, ctx) =>{\n    let analyser = ctx.createAnalyser();\n    analyser.connect(ctx.destination);\n    context.dispatch({type: types.CREATE_ANALYSER, payload: {ctx, analyser}})\n}\n\nexport const updateSources = (context, file) => {\n    let reader = new FileReader();\n    reader.onload = e => {\n        context.ctx.decodeAudioData(e.target.result, (buffer) => {\n            let sources = {...context.sources}\n            let name = file.name.split('.')[0]\n            let waveformData = buffer.getChannelData(0)\n            sources[context.selectedPad] = {buffer: buffer, name, isPlaying: false, waveformData}\n            let gridPadsArr = context.gridPadsArr;\n            let newSource = context.ctx.createBufferSource();\n            newSource.buffer = buffer;\n            gridPadsArr[context.selectedPad].source = newSource;\n            gridPadsArr[context.selectedPad].source.start()\n            gridPadsArr[context.selectedPad].sampleEnd = buffer.duration;\n            gridPadsArr[context.selectedPad].gainNode = context.ctx.createGain();\n            gridPadsArr[context.selectedPad].gainNode.connect(context.ctx.destination);\n            context.dispatch({type: types.UPDATE_SOURCES, payload: {sources, gridPadsArr}});\n        })\n    }\n    reader.readAsArrayBuffer(file);\n}\n\nexport const handlePadTrigger = (context, padId, velocity = 127) => {\n    let selectedSource =  context.sources[padId];\n    let selectedPad = padId\n    if(selectedSource && selectedSource.buffer){\n        if(context.gridPadsArr[padId].source && context.gridPadsArr[padId].selfMuted){\n            context.gridPadsArr[padId].source.stop();\n        }\n        let gridPadsArr = context.gridPadsArr;\n        let newSource = context.ctx.createBufferSource();\n        newSource.buffer = context.sources[padId].buffer;\n        gridPadsArr[padId].source = newSource;\n        gridPadsArr[padId].isPlaying = true;\n        if(context.selectedPad !== padId){\n            context.dispatch({type: types.HANDLE_PAD_TRIGGER, payload: {gridPadsArr, selectedPad}});\n        }\n        newSource.connect(context.gridPadsArr[padId].gainNode);\n        newSource.detune.value = context.gridPadsArr[padId].detune;\n        let currentGain = velocity !== 127 ? Math.pow(velocity, 2) / Math.pow(127, 2) : context.gridPadsArr[padId].currentGain;\n        context.gridPadsArr[padId].gainNode.gain.setValueAtTime(currentGain, context.ctx.currentTime)\n        context.gridPadsArr[padId].source.start(context.ctx.currentTime, context.gridPadsArr[padId].sampleStart , context.gridPadsArr[padId].sampleEnd);\n        context.gridPadsArr[padId].source.stop(context.ctx.currentTime + context.gridPadsArr[padId].sampleEnd);\n    } else {\n        if(context.selectedPad !== padId){\n            context.dispatch({type: types.HANDLE_PAD_TRIGGER, payload: {selectedPad}});\n        }\n    }\n}\n\nexport const handlePadStop = (context, padId, gridPadsArr) => {\n    if(context.gridPadsArr[padId].source && context.gridPadsArr[padId].selfMuted){\n        context.gridPadsArr[padId].source.stop();\n        context.gridPadsArr[padId].isPlaying = false\n        context.dispatch({type: types.HANDLE_PAD_STOP, payload: {gridPadsArr}});\n    }\n}\n\nexport const updateEditorData = ({context, cmd, val}) => {\n    let newPadsArr = context.gridPadsArr;\n    let selectedPad = context.selectedPad;\n    if(cmd === \"start\"){\n        if(val >= newPadsArr[context.selectedPad].sampleEnd) return;\n        newPadsArr[context.selectedPad].sampleStart = Number(val);\n    }\n    if(cmd === \"end\"){\n        if(val <= newPadsArr[context.selectedPad].sampleStart) return;\n        newPadsArr[context.selectedPad].sampleEnd = Number(val);\n    }\n    if(cmd === \"gain\"){\n        newPadsArr[context.selectedPad].currentGain = val;\n    }\n    if(cmd === \"detune\" && val !== \"Current\"){\n        newPadsArr[context.selectedPad].detune = val;\n    }\n    if(cmd === \"prev\"){\n        selectedPad = context.selectedPad + val < 0 ? context.gridPadsArr.length - 1 : context.selectedPad + val;\n    }\n    if(cmd === \"next\"){\n        selectedPad = context.selectedPad + val > context.gridPadsArr.length - 1 ?  0 : context.selectedPad + val;\n    }\n    if(cmd === \"play\"){\n        handlePadTrigger(context, context.selectedPad);\n    }\n    if(cmd === \"stop\"){\n        handlePadStop(context.selectedPad, newPadsArr);\n    }\n    if(cmd === \"color\"){\n        newPadsArr[context.selectedPad].color = Colors[val];\n    }\n    let payload = {gridPadsArr: newPadsArr, selectedPad}\n    context.dispatch({type: types.UPDATE_EDITOR_DATA, payload });\n}"]},"metadata":{},"sourceType":"module"}